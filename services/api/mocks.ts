// services/api/mocks.ts
import { IApiClient } from './client';
// FIX: Corrected import path for mock API functions.
import * as mockApi from '../geminiService';
// FIX: Corrected import path for types.
import { 
    BacktestAnalysisResult,
    PresentDayAnalysisResult, 
    PresentDayAssetSignal, 
    SelfAnalysis, 
    AlphaHuntData,
    RobustnessAuditReport,
    TradingDeskData,
    GlobalPerformanceData,
    GlobalPerformanceMetrics,
    LucraQuantumAnalysis,
    AsymmetricOpportunitiesData,
    AdaptiveBacktestResult,
    LivePrices,
    AssetCategory,
    HighConvictionSignal,
    ForwardSimulationResult,
    RiskSizingRecommendation,
    AssetSimulationBreakdown,
    ActualSimulationResult,
    SimulationAIAnalysis,
} from '../../types';

// This is a mock implementation of the API client interface.
// It uses the local mock data generators instead of making HTTP requests.
export const MockTransport: IApiClient = {
    fetchPresentDayAnalysis: async (): Promise<PresentDayAnalysisResult> => {
        console.log('[MOCK API] fetchPresentDayAnalysis called');
        await new Promise(resolve => setTimeout(resolve, 500)); // Simulate network delay
        return mockApi.generatePresentDayAnalysis();
    },
    fetchBacktestAnalysis: async (): Promise<BacktestAnalysisResult> => {
        console.log('[MOCK API] fetchBacktestAnalysis called');
        await new Promise(resolve => setTimeout(resolve, 1000));
        // The mock function now returns the full, correctly typed object
        return mockApi.generateBacktestAnalysis();
    },
    fetchAlphaHunt: async (): Promise<AlphaHuntData> => {
        console.log('[MOCK API] fetchAlphaHunt called');
        await new Promise(resolve => setTimeout(resolve, 800));
        const data = mockApi.generateAlphaHuntFromDailyAlpha();
        return data;
    },
    fetchSupervisorDirective: async (payload: { analysis: SelfAnalysis; promptText: string; }): Promise<{ directive: string }> => {
        console.log('[MOCK API] fetchSupervisorDirective called');
        await new Promise(resolve => setTimeout(resolve, 600));
        return { directive: `Diretiva de mock recebida e processada com sucesso para o modelo: ${payload.analysis.failedModel}.` };
    },
    fetchRobustnessAudit: async (): Promise<RobustnessAuditReport> => {
        console.log('[MOCK API] fetchRobustnessAudit called');
        await new Promise(resolve => setTimeout(resolve, 700));
        return mockApi.generateRobustnessAudit();
    },
    fetchTradingDeskData: async (): Promise<TradingDeskData> => {
        console.log('[MOCK API] fetchTradingDeskData called');
        await new Promise(resolve => setTimeout(resolve, 400));
        
        const mainAnalysis = await mockApi.generatePresentDayAnalysis();
        const highConvictionSignals: HighConvictionSignal[] = [];

        // 1. Add the three bullets automatically
        if (mainAnalysis.asymmetricArsenal.gold) {
            highConvictionSignals.push({ ticker: mainAnalysis.asymmetricArsenal.gold.ticker, type: 'gold' });
        }
        if (mainAnalysis.asymmetricArsenal.silver) {
            highConvictionSignals.push({ ticker: mainAnalysis.asymmetricArsenal.silver.ticker, type: 'silver' });
        }
        if (mainAnalysis.asymmetricArsenal.bronze) {
            highConvictionSignals.push({ ticker: mainAnalysis.asymmetricArsenal.bronze.ticker, type: 'bronze' });
        }

        // 2. Add top 3 opportunities from allAssets, excluding bullets
        const bulletTickers = highConvictionSignals.map(s => s.ticker);
        const topOpportunities = mainAnalysis.allAssets
            .filter(asset => !bulletTickers.includes(asset.ticker))
            .sort((a, b) => b.overallScore - a.overallScore)
            .slice(0, 3);

        topOpportunities.forEach(opp => {
            highConvictionSignals.push({ ticker: opp.ticker, type: 'opportunity' });
        });

        return {
            clusterPnl: [], // Will be calculated live
            forwardSimulation: null, // Will be generated by AI on demand
            riskSizing: null, // Will be generated by AI on load
            executionLog: [],
            highConvictionSignals: highConvictionSignals,
        };
    },
    fetchGlobalPerformance: async (): Promise<GlobalPerformanceData> => {
        console.log('[MOCK API] fetchGlobalPerformance called');
        await new Promise(resolve => setTimeout(resolve, 900));
        const history: GlobalPerformanceMetrics[] = [
            // FIX: Added missing properties to match GlobalPerformanceMetrics type
            { date: '2023-08-01', version: 'v9.8', successRate: 62.1, netRoi: 15.3, sharpeRatio: 1.75, maxDrawdown: -12.5, resilienceScore: 88, modelStability: 95, moduleConsistency: 92, cognitiveScore: 89 },
            { date: '2023-08-02', version: 'v9.8', successRate: 63.5, netRoi: 15.9, sharpeRatio: 1.81, maxDrawdown: -12.2, resilienceScore: 89, modelStability: 96, moduleConsistency: 93, cognitiveScore: 90 },
            { date: '2023-08-03', version: 'v9.9', successRate: 63.2, netRoi: 15.8, sharpeRatio: 1.79, maxDrawdown: -11.9, resilienceScore: 90, modelStability: 95, moduleConsistency: 94, cognitiveScore: 91 },
            { date: '2023-08-04', version: 'v9.9', successRate: 64.0, netRoi: 16.5, sharpeRatio: 1.85, maxDrawdown: -11.5, resilienceScore: 91, modelStability: 97, moduleConsistency: 95, cognitiveScore: 92 },
            { date: '2023-08-05', version: 'v10.0', successRate: 63.8, netRoi: 16.2, sharpeRatio: 1.82, maxDrawdown: -11.8, resilienceScore: 90, modelStability: 96, moduleConsistency: 94, cognitiveScore: 91 },
        ];
        return {
            latest: history[history.length-1],
            history: history
        };
    },
    fetchLucraQuantumAnalysis: async (): Promise<LucraQuantumAnalysis> => {
        console.log('[MOCK API] fetchLucraQuantumAnalysis called');
        await new Promise(resolve => setTimeout(resolve, 650));
        return {
            coherenceScore: 82,
            conflictAlerts: ["Fluxo de baleias diverge do Open Interest em prazos curtos."],
            riskVector: 'Moderado',
        };
    },
    fetchMarketPrices: async (assets: string[]): Promise<LivePrices> => {
        console.log(`[MOCK API] fetchMarketPrices called for ${assets.join(', ')}`);
        await new Promise(resolve => setTimeout(resolve, 300));
        const prices: LivePrices = {};
        assets.forEach(asset => {
            // Just return some fake prices for mock mode
            if (asset === 'BTC') prices[asset] = 68000.50;
            else if (asset === 'ETH') prices[asset] = 3800.25;
            else if (asset === 'SOL') prices[asset] = 150.75;
            else if (asset === 'RNDR') prices[asset] = 10.85;
            else if (asset === 'KAS') prices[asset] = 0.155;
            else if (asset === 'PAAL') prices[asset] = 0.41; // Gold bullet, in range
            else if (asset === 'INJ') prices[asset] = 24.0; // Bronze bullet, stable price above stop
            else prices[asset] = Math.random() * 1000 + (asset.length * 10);
        });
        return prices;
    },
    fetchSignalDetails: async (ticker: string, category: AssetCategory): Promise<PresentDayAssetSignal> => {
        console.log(`[MOCK API] fetchSignalDetails called for ${ticker}`);
        await new Promise(resolve => setTimeout(resolve, 400));
        return mockApi.generateSignalDetails(ticker, category);
    },
    // FIX: Implemented mock function for fetching asymmetric opportunities data.
    fetchAsymmetricOpportunitiesData: async (): Promise<AsymmetricOpportunitiesData> => {
        console.log('[MOCK API] fetchAsymmetricOpportunitiesData called');
        await new Promise(resolve => setTimeout(resolve, 600));
        return {
            top10: [
                { name: 'Kaspa', ticker: 'KAS', classification: 'Bala de Ouro', rationale: 'L1 PoW com alta vazão e segurança, ganhando tração para pagamentos digitais.', explosionScore: 95, metrics: { volumeAnomalydelta: 150, newHoldersDelta: 25, socialMentionsDelta: 80 } },
                { name: 'Bittensor', ticker: 'TAO', classification: 'Projétil Fantasma', rationale: 'Mercado descentralizado para IA, permitindo que modelos compitam e sejam recompensados.', explosionScore: 92, metrics: { volumeAnomalydelta: 120, newHoldersDelta: 18, socialMentionsDelta: 65 } },
                { name: 'Pepe', ticker: 'PEPE', classification: 'Zona Radioativa', rationale: 'Memecoin com forte comunidade e potencial para novas altas explosivas, mas com risco extremo.', explosionScore: 88, metrics: { volumeAnomalydelta: 250, newHoldersDelta: 40, socialMentionsDelta: 150 } },
            ]
        };
    },
    runForwardSimulation: async (signals: HighConvictionSignal[]): Promise<ForwardSimulationResult> => {
        console.log(`[MOCK API] runForwardSimulation called for: ${signals.map(s=>s.ticker).join(', ')}`);
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        if(signals.length === 0) {
            // Should not happen if button is disabled, but as a safeguard:
            return {
                total: { optimistic: { pnlPercentage: 0 }, neutral: { pnlPercentage: 0 }, pessimistic: { pnlPercentage: 0 } },
                breakdown: [],
                rationale: "Nenhum ativo selecionado para simulação."
            };
        }

        const breakdown: AssetSimulationBreakdown[] = signals.map(signal => {
            const base = (signal.ticker.length % 5) * 2; // pseudo-random base
            return {
                ticker: signal.ticker,
                optimistic: { pnlPercentage: 10 + base + Math.random() * 10 },
                neutral: { pnlPercentage: 2 + base/2 + Math.random() * 5 },
                pessimistic: { pnlPercentage: -5 - base/3 - Math.random() * 5 },
            };
        });

        const total = breakdown.reduce((acc, curr) => {
            acc.optimistic.pnlPercentage += curr.optimistic.pnlPercentage;
            acc.neutral.pnlPercentage += curr.neutral.pnlPercentage;
            acc.pessimistic.pnlPercentage += curr.pessimistic.pnlPercentage;
            return acc;
        }, { 
            optimistic: { pnlPercentage: 0 }, 
            neutral: { pnlPercentage: 0 }, 
            pessimistic: { pnlPercentage: 0 } 
        });

        total.optimistic.pnlPercentage /= signals.length;
        total.neutral.pnlPercentage /= signals.length;
        total.pessimistic.pnlPercentage /= signals.length;

        return {
            total,
            breakdown,
            rationale: `Simulação de portfólio para ${signals.length} ativo(s) selecionado(s), ponderando volatilidade individual e correlação de mercado.`
        };
    },
    runRiskAnalysis: async (): Promise<RiskSizingRecommendation> => {
        console.log('[MOCK API] runRiskAnalysis called');
        await new Promise(resolve => setTimeout(resolve, 800));
        return {
            maxPortfolioRisk: 2.0,
            idealPositionSize: 4.5,
            maxLeverage: 5,
            rationale: "Dado os sinais de exaustão do mercado, uma abordagem de risco mais conservadora é aconselhada."
        };
    },
    runSimulationValidation: async (payload: { prediction: ForwardSimulationResult; actual: ActualSimulationResult; }): Promise<SimulationAIAnalysis> => {
        console.log('[MOCK API] runSimulationValidation called');
        await new Promise(resolve => setTimeout(resolve, 1200));

        const { prediction, actual } = payload;
        const actualPnl = actual.pnlPercentage;

        const scenarios = {
            optimistic: prediction.total.optimistic.pnlPercentage,
            neutral: prediction.total.neutral.pnlPercentage,
            pessimistic: prediction.total.pessimistic.pnlPercentage,
        };
        
        const diffs = {
            optimistic: Math.abs(actualPnl - scenarios.optimistic),
            neutral: Math.abs(actualPnl - scenarios.neutral),
            pessimistic: Math.abs(actualPnl - scenarios.pessimistic),
        };

        const closestScenario = Object.keys(diffs).reduce((a, b) => diffs[a as keyof typeof diffs] < diffs[b as keyof typeof diffs] ? a : b) as 'optimistic' | 'neutral' | 'pessimistic';

        let rationale = `A previsão foi precisa. O resultado real (${actualPnl.toFixed(2)}%) ficou mais próximo do cenário '${closestScenario}' (${scenarios[closestScenario].toFixed(2)}%). `;
        if (closestScenario === 'optimistic' && actualPnl > scenarios.optimistic) {
            rationale += "O mercado se moveu com mais força do que o esperado, superando a projeção otimista devido a notícias inesperadas."
        } else if (closestScenario === 'pessimistic' && actualPnl < scenarios.pessimistic) {
            rationale += "A queda foi mais acentuada do que o previsto no cenário pessimista, indicando uma capitulação de mercado não antecipada."
        } else {
             rationale += "A volatilidade se manteve dentro dos parâmetros esperados para o período."
        }

        return {
            closestScenario,
            rationale,
        };
    },
};